function worker(
        tq, -- Task queue, in the form of:
            -- {
            --  ['func'] = functionToExecute,
            --  ['...'] = Any additional arguments to pass to the function
            -- }

        rq  -- Result queue
        )

    -- Set the max amount of time to run the worker for
    timeout = timeout or 15
    local end_time = os.clock() + timeout --Seconds

    while (os.clock() < end_time) do

        -- Check the queue for a task, or wait a random number of frames
        if next(tq) == nil then

            local count = 0
            local wait_frames = math.random(20, 70)
            log('No task found in queue, waiting ['..tostring(wait_frames)..']',
                'worker')
            while count < wait_frames do
                count = count + 1
                coroutine.yield(0)
            end
        else
            args = table.remove(tq, 1)

            -- Check if the worker should be killed
            if args == 'STOPQUEUE' then
                log('Killing worker', 'worker')
                table.insert(tq, 'STOPQUEUE')
                return 1
            end
            log('Worker got task!', 'worker')
            local result = args.task(args)
            log('Worker finished with result: ['..tostring(result)..']', 'worker')
            table.insert(rq, result)
        end
    end
    log('Killing worker due to timeout', 'worker')
end
