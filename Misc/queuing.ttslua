function worker(
        tq, -- Task queue, in the form of:
            -- {
            --  ['func'] = functionToExecute,
            --  ['...'] = Any additional arguments to pass to the function
            -- }

        rq,  -- Result queue
        timeout
        )

    -- Set the max amount of time to run the worker for
    timeout = timeout or 15
    local end_time = os.clock() + timeout --Seconds

    while (os.clock() < end_time) do

        -- Check the queue for a task, or wait a random number of frames
        if next(tq) == nil then

            local count = 0
            local wait_frames = math.random(20, 70)
            -- log('worker: No task; waiting ['..tostring(wait_frames)..'] frames')
            while count < wait_frames do
                count = count + 1
                coroutine.yield(0)
            end
        else
            args = table.remove(tq, 1)

            -- Check if the worker should be killed
            if args == 'STOPQUEUE' then
                log('worker: Got term signal')
                table.insert(tq, 'STOPQUEUE')
                return 1
            end
            log('worker: Got task!')
            local result = args.task(args)
            log('worker: Worker finished with result: ['..tostring(result)..']')
            table.insert(rq, result)
        end
    end
    log('worker: Killing worker due to timeout')
    return 1
end
